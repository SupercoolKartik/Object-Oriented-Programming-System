 The word “polymorphism” means having many forms. 
Poly -> Many
Morph -> Forms

**Polymorphism is defined as the ability of a message to be displayed in more than one form.**
A real-life example of polymorphism is a person who at the same time can have different characteristics. A man at the same time is a father, a husband, and an employee. So the same person exhibits different behavior in different situations. This is called polymorphism.
Polymorphism is considered one of the important features of Object-Oriented Programming.


## Types of Polymorphism
- **Compile-time Polymorphism**
- **Runtime Polymorphism**


##  Compile-Time Polymorphism
This type of polymorphism is achieved by **function overloading** or **operator overloading.**


#### A. Function Overloading

Function overloading **allows you to have multiple functions with the same name** in the same scope. The **compiler determines which function to call based on the number and types of arguments** passed to the function.


```
#include <iostream>
using namespace std;

class Print {
public:
    void show(int i) {
        cout << "Integer: " << i << endl;
    }
    
    void show(int a, int b){
        cout << "Integers: "<< a<<","<<b<<endl;    
    }
    
    void show(double d) {
        cout << "Double: " << d << endl;
    }

    void show(string s) {
        cout << "String: " << s << endl;
    }
};

int main() {
    Print p;
    p.show(5);         // Calls show(int)
    p.show(6,7);       // Calls show(int,int)
    p.show(3.14);      // Calls show(double)
    p.show("Hello");   // Calls show(string)
    return 0;
}

```

#### B. Operator Overloading
Operator overloading **allows defining or altering the behavior of operators for user-defined types (classes or structs)**. This enhances the readability and usability of objects of those classes.
It is a compile-time polymorphism.
It is an idea of giving special meaning to an existing operator in C++ without changing its original meaning.

**For example**, we can overload an operator ‘+’ in a class like String so that we can concatenate two strings by just using +.

In this example bellow, we have 3 variables “a1”, “a2” and “a3” of type “class A”.

```
class A {
    statements;
};

int main()
{
    A a1, a2, a3;

    a3 = a1 + a2;

    return 0;
}
```

Here we are trying to add two objects “a1” and “a2”, which are of user-defined type i.e. of type “class A” using the “+” operator. This is not allowed, because the addition operator “+” is predefined to operate only on built-in data types. But here, “class A” is a user-defined type, so the compiler generates an error. This is where the concept of “Operator overloading” comes in.

Now, if the user wants to make the operator “+” add two class objects, the user has to redefine the meaning of the “+” operator such that it adds two class objects. This is done by using the concept of “Operator overloading”. So the main idea behind “Operator overloading” is to use C++ operators with class variables or class objects. Redefining the meaning of operators really does not change their original meaning; instead, they have been given additional meaning along with their existing ones.

```
// C++ Program to Demonstrate
// Operator Overloading
#include <iostream>
using namespace std;

class Complex {
private:
    int real, imag;

public:
    Complex(int r = 0, int i = 0)
    {
        real = r;
        imag = i;
    }

    // This is automatically called when '+' is used with
    // between two Complex objects
    Complex operator+(Complex const& obj)
    {
        Complex res;
        res.real = real + obj.real;
        res.imag = imag + obj.imag;
        return res;
    }
    void print() { cout << real << " + i" << imag << '\n'; }
};

int main()
{
    Complex c1(10, 5), c2(2, 4);
    Complex c3 = c1 + c2;
    c3.print();
}

```

```
Output -> 12 + i9
```

## ==**Can We Overload All Operators?**==

Almost all operators can be overloaded except a few. Following is the list of operators that cannot be overloaded.

sizeof  
typeid  
Scope resolution (::)  
Class member access operators (.(dot), .* (pointer to member operator))  
Ternary or conditional (?:)

## ==**Operators that can be Overloaded in C++**==
We can overload
- **Unary operators**
- **Binary operators**
- **Special operators**( [ ], (), etc)

|Operators that can be overloaded|Examples|
|---|---|
|Binary Arithmetic|+, -, *, /, %|
|Unary Arithmetic|+, -, ++, —|
|Assignment|=, +=,*=, /=,-=, %=|
|Bitwise|& , \| , << , >> , ~ , ^|
|De-referencing|(->)|
|Dynamic memory allocation,  <br>De-allocation|New, delete|
|Subscript|[ ]|
|Function call|()|
|Logical|&,  \| \|, !|
|Relational|>, < , = =, <=, >=|

## ==**Why can’t the above-stated operators be overloaded?**==
https://www.geeksforgeeks.org/operator-overloading-cpp/#:~:text=Why%20can%E2%80%99t%20the%20above%2Dstated%20operators%20be%20overloaded%3F

